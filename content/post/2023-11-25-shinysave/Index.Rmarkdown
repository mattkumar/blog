---
title: saving sessions (+ shinylive)
author: Matthew Kumar
date: '2023-11-25'
slug: purrr
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

It pains me ğŸ˜© that whenever I contemplate using shiny for a work-related project, the question of allowing users to save and restore their progress ğŸ’¬ğŸ—¨ inevitably arises.

While there are a variety of ways to do so in shiny (e.g. bookmarks), work-related apps aren't always so straight forward ğŸ”€

For example:
1.  They are usually tied to remote raw data that must be accessed with a live connection ğŸ“²
2.  They involve intermediate calculations that aren't easily restored by simply saving and reloading input values on the UI  ğŸ‘¨â€ğŸ”¬

Well, I finally took the time to ğŸ”¨ and I'm here to share what I've learned ğŸ‘¨â€ğŸ«
<br>

<hr>

âš¡ï¸<strong>Sidebarâš¡ï¸ </strong>Today is a bit of a 2 for 1. The demo app I've cooked up is using [shinylive](https://posit-dev.github.io/r-shinylive/)! In a nutshell, the app is ran serverless in the browser via [webR](https://docs.r-wasm.org/webr/latest/). More on that later.

<hr>

<br>

## Approach

For simplicity, I've crafted a small app enabling users to upload a SAS Transport (.XPT) data file. The file is parsed using the `{haven}` package and presented as a table on the UI. There's also an additional textInput field for users to enter their name.

Upon visiting the app, users can either:
1.  Start by uploading a fresh file ğŸ“„
2.  Begin by restoring a previously saved session ğŸ’¾

This is achieved through a radioButtons control. Upon making a choice, the corresponding fileInput widget is displayed.

When a fresh file is uploaded ğŸ“¤, it is read in as binary ğŸ‘¨â€ğŸ’» (using `readBin` and `writeBin`) in a reactiveValues container. Additional ğŸ›  steps, such as implementing `haven::read_xpt()` to another value in the reactiveValues, occur to make it immediately available for use in the app and later. This process unfolds inside an observeEvent ğŸ”.

The "session saving" âœ¨ is managed by a `downloadHandler `ğŸ“¥. The content is populated by all current values in the reactiveValues via `reactiveValuesToList` ğŸ’ª. This includes the binary representation of the .XPT file and possibly the processed version. Additionally, other inputs ğŸš can be arbitrarily specified for storage in the file (remember the random textInput asking for your name?).

So, what happens when you start the app by wanting to restore a previous sessionâ“ï¸ Using the radioButton choice for that, the appropriate fileInput widget is first made available. Once uploaded, the processing essentially involves reassigning all values ğŸ“ from the saved file to the current values in the reactiveValues. For other inputs, such as the textInput, the corresponding updateTextInput is used to restore that value directly. This process takes place within an observeEvent ğŸ”.


## tl;dr
A consequence of this approach is this: 
> The save file retains a binary representation of your original file. As such you can recreate that file behind the scenes thus making <strong>your app no longer depend on remote access to it</strong>. Consider that anything can be represented as binary including file types like CSVs, Docx, Images, etc. ğŸ˜µ 



## Shinylive App

You can give this a try in the live app embedded below ğŸ‘‡ğŸ‘‡ğŸ‘‡ 

ğŸ‘‰ Use this save file I generated: <a href="https://raw.githubusercontent.com/mattkumar/blog/main/content/post/2023-11-25-shinysave/my_saved_session.RData" download="my_saved_session.RData">Download my_saved_session.RData</a>

When you upload it, you'll see my progress. You'll also see the contents of the save file, which shows both the binary representation of the source file (which you don't have).

<iframe src="https://mattkumar.github.io/shinysave" width="100%" height="600", style = "border: none;"></iframe>


## Thoughts

I'm not sure if I'm idealizing ğŸ˜ finally having a solution to a long-standing problem, but I'm excited ğŸ¤£. The scalability remains uncertain, so it's probably best implemented prospectively ğŸ”œ rather than retro ğŸ”™.

Another consideration is the source files themselves. In some cases, storing a "copy" of the data outside its origin might violate company policy ğŸ•µ. There's definitely some gray area. In other roles, users already self-manage their own document files in various ways ğŸ¤” ğŸ¤” ğŸ¤” 

And what about file size ğŸ“ˆ ? In this example, the original XPT was 116 kb and the save file was 33.9 kb. Obviously some savings there, but where does that bottom out ğŸ‹? It might depend on the format of the original file type.


## Shinylive

As mentioned earlier, I've used this post as a two-for-one. Since this app is relatively lightweight, I employed `shinylive::export` to convert it to a format I can host as static content (currently on GitHub pages) ğŸ¤‘

It was pretty straight forward and overall looks promising. However, there are a few things to be âš ï¸ mindful of: Because all of the work ğŸ‘· is done in the browser it may take time for things to load âŒ›. Another key consideration is whether your app package dependencies ğŸ“¦ are compatible with `webR`. Interactive documentation ğŸ“‹ on the latter can be found [here](https://repo.r-wasm.org/)

## Resources


   ğŸ‘‰ [link to shinylive app](https://mattkumar.github.io/shinysave) 
   
   ğŸ‘‰ [github repository with code](https://github.com/mattkumar/shinysave/)  
<br>
<br>
<br>
<br>
Till next time ğŸ»ğŸ™ !